<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo with GitHub Page - 建立屬於自己的部落格</title>
    <url>/2021/12/02/20211202-1/</url>
    <content><![CDATA[<p>你是否想過分享自己寫完的筆記或是文章嗎?但又不想做一些很麻煩的事情來實踐這個想法<br>那麼透過 Hexo 來建立屬於自己的部落格會是你一個好選擇！</p>
<span id="more"></span>

<!-- Hexo 介紹 -->
<h3 id="什麼是-Hexo"><a href="#什麼是-Hexo" class="headerlink" title="什麼是 Hexo"></a>什麼是 Hexo</h3><p>Hexo 是一款基於 Node.js 的網誌框架,它不僅能夠快速、簡單的建立屬於自己風格的部落格，還能使用 Markdown 的語法來撰寫文章，甚至能在幾秒鐘的時間就將自己的部落格部署到免費的雲端服務上(Heroku、GitHub Page)。</p>
<p>Hexo 擁有豐富的開源生態，因此有許多功能插件或是主題可以使用，這也是為什麼 Hexo 這麼多人使用的原因之一。</p>
<h4 id="使用-Hexo-的優點"><a href="#使用-Hexo-的優點" class="headerlink" title="使用 Hexo 的優點"></a>使用 Hexo 的優點</h4><ol>
<li>使用 Markdown 語法撰寫文，上手難度相較簡單</li>
<li>可搭配線上 CICD 工具快速部署於各種免費雲端服務上，不需額外花費金錢成本</li>
<li>中文文件資源多</li>
<li>開源社群活躍</li>
<li>基於 Node.js 擁有豐富的功能插件</li>
<li>擁有許多模板，能快速切換自己喜歡的樣式</li>
</ol>
<!-- Hexo 安裝 -->
<h3 id="Hexo-的初始化安裝"><a href="#Hexo-的初始化安裝" class="headerlink" title="Hexo 的初始化安裝"></a>Hexo 的初始化安裝</h3><p>安裝前請先檢查電腦上有以下兩個環境</p>
<ul>
<li>Git</li>
<li>Node.js</li>
</ul>
<p>如果上面兩個都安裝完畢了，只要cmd內輸入下面這行即可以安裝好 Hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>如果都還沒安裝可依照以下的網址或步驟下載</p>
<h4 id="安裝-Git"><a href="#安裝-Git" class="headerlink" title="安裝 Git"></a>安裝 Git</h4><ul>
<li>Windows<br>  <a href="https://git-scm.com/download/win">下載並安裝 Git</a></li>
<li>Mac<ol>
<li>下載 Homebrew<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br></pre></td></tr></table></figure></li>
<li>下載 Git<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>Linux(Ubuntu)  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git-core</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="安裝-Node-js"><a href="#安裝-Node-js" class="headerlink" title="安裝 Node.js"></a>安裝 Node.js</h4><ul>
<li><a href="https://nodejs.org/en/">官網下載</a></li>
<li>Mac  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure></li>
</ul>
<!-- Hexo 建立專案 -->
<h3 id="建立初始化的-Hexo-Blog"><a href="#建立初始化的-Hexo-Blog" class="headerlink" title="建立初始化的 Hexo Blog"></a>建立初始化的 Hexo Blog</h3><p>首先在你要放 Blog 專案的資料夾下輸入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init [filename]</span><br></pre></td></tr></table></figure>

<p>接著利用 npm 安裝相關 Hexo 套件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>這時已經完成本地端伺服器的架設了<br>利用以下指令即可在 <a href="http://localhost:4000/">http://localhost:4000</a> 開啟 server</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line">// or</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<!-- Hexo 檔案介紹 -->
<h3 id="Hexo-檔案介紹"><a href="#Hexo-檔案介紹" class="headerlink" title="Hexo 檔案介紹"></a>Hexo 檔案介紹</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.landscape.yml // 初始化 themes 的配置檔 (可刪除)</span><br><span class="line">├── _config.yml           // Blog 的配置檔</span><br><span class="line">├── node_modules          </span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json          // Node 的依賴套件</span><br><span class="line">├── scaffolds             // 文章格式</span><br><span class="line">├── source                // 各種外部資源(Ex: 圖片、文章md檔)</span><br><span class="line">└── themes                // Blog 的模板</span><br></pre></td></tr></table></figure>
<h4 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h4><p>當建立新文章時，Hexo 會根據 scaffold 資料夾內相對應的檔案來建立檔案<br>Ex: 文章格式 (scaffolds/post.md)<br>    <img src="https://scontent.ftpe4-2.fna.fbcdn.net/v/t1.15752-9/263023196_1496334174082631_4588728063359370907_n.png?_nc_cat=100&ccb=1-5&_nc_sid=ae9488&_nc_ohc=vrI8f1F368MAX_-aqRl&_nc_ht=scontent.ftpe4-2.fna&oh=be538779d96e41c2ddd103ca85ce0bc9&oe=61CF31EB"></p>
<p>會產生出符合預設規範的文章<br><img src="https://scontent.ftpe4-1.fna.fbcdn.net/v/t1.15752-9/260593912_242177871343601_7214120357166358976_n.png?_nc_cat=106&ccb=1-5&_nc_sid=ae9488&_nc_ohc=N-w9r-YGOFwAX__V0NN&_nc_ht=scontent.ftpe4-1.fna&oh=36f3e6cd11c50e068c842e3fbae30fad&oe=61CEBDEB"></p>
<p>產生新文章語法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new post1</span><br></pre></td></tr></table></figure>

<h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>source 資料夾是放置內容的地方。所有的檔案或是資料夾通常都會在這邊，開頭會加上 _(底線) 來命名，讓這些資料夾或是檔案也成為隱藏檔案而被忽略，除了 _posts 資料夾以外。Markdown 和 HTML 檔案會被發布並存放到 public 資料夾，而其他檔案沒有以底線命名的就會被拷貝過去。</p>
<h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><p>themes 資料夾是放置所有 Hexo 的樣式，只要把喜歡的樣式放入此資料夾，再調整 _config.yml 後,就可以設定成該樣式。</p>
<h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>_config.yml 是整個 Hexo 的配置檔，網站的各種配置設定都在這邊，Ex：網頁標題、網站描述、網站的網址、路徑等等<br><a href="https://hexo.io/zh-tw/docs/configuration">更多詳細設定內容</a></p>
<!-- Hexo 樣式轉換 -->
<h3 id="如何更換-Hexo-的樣式"><a href="#如何更換-Hexo-的樣式" class="headerlink" title="如何更換 Hexo 的樣式"></a>如何更換 Hexo 的樣式</h3><p>這邊以 <a href="https://github.com/theme-next/hexo-theme-next">Next</a> 的樣式為例<br><a href="https://hexo.io/themes/">更多樣式</a></p>
<p>首先先移動到 themes 的資料夾內, 並輸入以下語法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next next </span><br></pre></td></tr></table></figure>

<p>接者把 _config.yml 內的 theme 資訊修改為 next </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>再重新啟動一次server就可以看到樣式變更了哦</p>
<!-- 部署 -->
<h3 id="Github-Page-部署"><a href="#Github-Page-部署" class="headerlink" title="Github Page 部署"></a>Github Page 部署</h3><p>為了讓自己設計好的Blog可以在網路上被查詢到，雖然有很多方法都可以達到這個需求，但今天要教學是既簡單又暴力,重點還是一個免費的方法，那就是利用GitHub Page的方式。</p>
<p>首先先在 GitHub 建立名為<font color=#e9967a>username.github.io</font>的公開 Repository<br>username : 自己 GitHub 的名稱<br><img src="https://scontent.ftpe4-2.fna.fbcdn.net/v/t1.15752-9/259977906_416803966770968_3012149253162255843_n.png?_nc_cat=102&ccb=1-5&_nc_sid=ae9488&_nc_ohc=tqlqnB_dcPMAX8f828b&tn=8BkEQnO2Oqqy053t&_nc_ht=scontent.ftpe4-2.fna&oh=c7b5f32081b3afe5587cf0603663827d&oe=61CE7100"></p>
<p>接著是在 _config.yml 設定要部署到這個 Repository中<br><a href="https://hexo.io/docs/one-command-deployment">Hexo 文件</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">&quot;repository 的 github 網址&quot;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span> <span class="comment"># 哪個分支上 </span></span><br></pre></td></tr></table></figure>

<p>再來就是將自己設計好的Hexo專案部署到 GitHub Page 上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// step1. clean - 清除舊的網頁靜態檔</span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">// step2. generate - 產生新的網頁靜態檔</span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line">// step3. deploy - 部署</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>最後就是等待 GitHub 部署完成囉～ 這個可能要等待一段時間才會完成</p>
<!-- Hexo 結語 -->
<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>那這篇文章是想要紀錄自己踩坑 Hexo 的過程，其實還有很多東西沒有提到，像是其他額外插件功能之類的，那這部分就要請讀者自行去研究囉～</p>
<p>最後由於第一次寫文章，有寫不好的地方再請大家見諒。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>GitHub Page</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 快取機制 &amp; 淘汰機制</title>
    <url>/2021/12/15/20211215-1/</url>
    <content><![CDATA[<p>在高效能、高併發的系統中, 快取機制是相當重要的, 那麼為什麼Redis可以當作快取機制的使用呢?<br>首先可以作為快取有主要以下兩個特徵: </p>
<ol>
<li>在分散系統中處於記憶體/CPU需具備訪問效能良好</li>
<li>快取資料過於飽足時, 需要有良好的資料淘汰機制去處理</li>
</ol>
<p>由於 Redis 天生就具有這兩個特徵, Redis基於記憶體操作的, 且其具有完善的資料淘汰機制, 十分適合作為快取機制的基礎。</p>
<span id="more"></span>
<h3 id="Redis-資料淘汰機制"><a href="#Redis-資料淘汰機制" class="headerlink" title="Redis 資料淘汰機制"></a>Redis 資料淘汰機制</h3><p>Redis 快取是基於記憶體實現的, 也因為這個原因導致儲存容量是有限制的, 所以當 Redis 快取被寫滿的時候, Redis就需要快取資料淘汰機制, 通過一定淘汰規則將一些資料篩選出來並刪除, 讓快取機制可以繼續使用。</p>
<p>在 Redis 4.0 之後, Redis 快取淘汰策略總共有8種, 包含三大類</p>
<ol>
<li>不淘汰資料<ul>
<li>noeviction : 不進行資料淘汰, 當快取被寫滿後, Redis返回錯誤</li>
</ul>
</li>
<li>在<strong>有設定過期時間的資料中</strong>篩選刪除<ul>
<li>volatile-random : 在有設定過期時間的資料中隨機刪除</li>
<li>volatile-ttl : 在有設定過期時間的資料中, 基於過期時間的先後進行刪除, 越早過期的越先被刪除</li>
<li>volatile-lru : 基於 LRU (Least Recently Used) 演算法篩選有設定過期時間的資料中, 近期最少使用的原則來篩選資料刪除</li>
<li>volatile-lfu : 使用 LFU (Least Frequently Used) 演算法選擇有設定過期時間的資料中, 近期使用頻率最少的資料來篩選資料刪除</li>
</ul>
</li>
<li>在<strong>所有資料中</strong>篩選刪除<ul>
<li>allkeys-random : 在所有資料中隨機刪除</li>
<li>allkeys-lru : 基於 LRU (Least Recently Used) 演算法在所有資料中來篩選刪除</li>
<li>allkeys-lfu : 基於 LFU (Least Frequently Used) 演算法在所有資料中來篩選刪除</li>
</ul>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fe5357b0f514e06b095ead23e60faa9~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="LRU-近期最少使用"><a href="#LRU-近期最少使用" class="headerlink" title="LRU - 近期最少使用"></a>LRU - 近期最少使用</h4><p>Least Recently Used 演算法, 概念是會儲存最近用過的內容, 會透過 Hash Map 與 Double Linked List 來搭配實做, 如果常被使用, 內容會被擺在 List 愈前方的位置, 如果快取滿了, 則會從 List 最末端元素開始移除。</p>
<ul>
<li>MRU 端 : 代表最近最常使用</li>
<li>LRU 端 : 最近最不常用</li>
</ul>
<p>補充 : 搜尋的時間複雜度O(1)<br><img src="https://imgur.com/WkpPJlT.png"></p>
<p>LRU 需要透過 Linked List 來管理所有快取資料, 這會帶來額外的空間開銷, 再加上當有資料被訪問時,需要在 Linked List 上把該資料移動到 MRU 端, 如果有大量資料被訪問, 就會帶來很多連結串列移動操作, 會很耗時，進而會降低 Redis 快取效能。</p>
<h4 id="LFU-近期使用頻率最少"><a href="#LFU-近期使用頻率最少" class="headerlink" title="LFU - 近期使用頻率最少"></a>LFU - 近期使用頻率最少</h4><p>Least Frequently Used 演算法, 是一定時期內被訪問次數最少的節點, 在將來被訪問到的機率也是最小的。</p>
<p>LFU有兩種實現方式</p>
<ol>
<li>雜湊表+平衡二叉樹</li>
<li>雙雜湊表</li>
</ol>
<p>雙雜湊表<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b04d307959624cc88fea4f61be71f5d0~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>雙雜湊表需要維護兩個雜湊表以及一個最少頻次使用的計數minFreq</p>
<p>第一個雜湊表是 freq_table, 它的key是訪問的頻次, 它的 value 是一個雙向連結串列, 雙向連結串列的每一個節點包含三個元素 : key, value, 以及count。</p>
<p>第二個雜湊表是 key_table, 它的key是雙向連結串列中儲存的key, value 是對應節點的指標(這樣查詢的時間複雜度就是O(1))。</p>
<h3 id="Redis-快取模式"><a href="#Redis-快取模式" class="headerlink" title="Redis 快取模式"></a>Redis 快取模式</h3><p>Redis快取模式基於是否接收寫請求, 可以分成只讀快取和讀寫快取兩種</p>
<ol>
<li>只讀快取 : 只處理讀操作, 所有的更新操作都在資料庫中, 這樣資料不會有丟失的風險。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0fbbd780eb84685895843b88a9972a3~tplv-k3u1fbpfcp-zoom-1.image"><ul>
<li>Cache Aside模式</li>
</ul>
</li>
<li>讀寫快取 : 讀寫操作都在快取中執行, 出現當機故障, 會導致資料丟失。快取回寫資料到資料庫有分成兩種同步和非同步。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73fe11d51ca34412bb703d6b8879a88e~tplv-k3u1fbpfcp-zoom-1.image"><ul>
<li>同步<ul>
<li>Read-Throug模式</li>
<li>Write-Through模式</li>
</ul>
</li>
<li>非同步<ul>
<li>Write-Behind模式</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="Cache-Aside模式"><a href="#Cache-Aside模式" class="headerlink" title="Cache Aside模式"></a>Cache Aside模式</h4><p>查詢資料時, 會先去快取中找有沒有資料, 如果沒有資料後才會去資料庫中取得資料, 獲取資料後會將資料儲存到快取中。<br>操作更新或刪除操作時, 會先將資料庫的操作成功後, 才會處理快取的部分。</p>
<p>Cache Aside模式存在著併發風險 : 執行讀操作未命中快取, 然後查詢資料庫中取資料, 資料已經查詢到還沒放入快取, 同一時間併發了一個更新的操作讓快取失效, 然後讀操作再把查詢到資料載入快取，導致快取的資料是沒有更新後的資料。</p>
<h4 id="Read-Write-Throug模式"><a href="#Read-Write-Throug模式" class="headerlink" title="Read/Write-Throug模式"></a>Read/Write-Throug模式</h4><p>查詢資料和更新資料都直接操作快取, 快取以同步方式將資料更新回資料庫中。出現髒資料的概率較低, 但是就非常依賴快取, 對快取的穩定性有較大要求, 但同步更新會導致其效能不好。</p>
<h4 id="Write-Behind模式"><a href="#Write-Behind模式" class="headerlink" title="Write Behind模式"></a>Write Behind模式</h4><p>查詢資料和更新資料都直接操作快取, 但快取服務以非同步方式地將資料更新回資料庫中(通過非同步任務), 速度快, 效率會非常高, 但是資料的一致性比較差, 還可能會有資料的丟失情況, 實現邏輯也較為複雜。</p>
<h3 id="使用快取常見的問題"><a href="#使用快取常見的問題" class="headerlink" title="使用快取常見的問題"></a>使用快取常見的問題</h3><h4 id="快取與資料庫資料不一致"><a href="#快取與資料庫資料不一致" class="headerlink" title="快取與資料庫資料不一致"></a>快取與資料庫資料不一致</h4><ul>
<li><p>只讀快取(Cache Aside模式)<br>讀操作都發生在快取中, 資料不一致只會發生在刪除和修改操作上(新增操作不會, 因為新增只會在資料庫處理)當發生刪除或修改操作時, 快取也需要跟著資料庫做更新或刪除, 因此在資料庫和快取處理過程中, 無論這兩個操作的執行順序, 只要有一個操作失敗了就會出現資料不一致的情況。</p>
</li>
<li><p>讀寫快取(Read/Write-Throug、Write Behind模式)<br>對於讀寫快取, 寫操作都發生在快取中, 後再更新資料庫, 只要有一個操作失敗了就會出現資料不一致的情況。</p>
</li>
</ul>
<h4 id="快取雪崩"><a href="#快取雪崩" class="headerlink" title="快取雪崩"></a>快取雪崩</h4><p>由於快取中有大量資料同時過期失效或者快取出現問題, 大量的請求無法在 Redis 快取中取得資料, 進而要到資料庫去找資料, 導致資料庫的壓力增加, 嚴重的會造成資料庫當機。</p>
<p>解決方案</p>
<ul>
<li>快取中有大量資料同時過期, 導致大量請求無法得到處理<ul>
<li>資料預熱 : 將容易發生併發的資料先透過手動觸發提早存入快取中。</li>
<li>設定不同的過期時間, 讓過期的時間點分散。</li>
<li>雙層快取策略 : 在原快取上加上拷貝快取, 原快取失效時可以訪問拷貝快取, 且原快取失效時間設定為短期, 拷貝快取設定為長期。</li>
<li>服務降級 : 發生快取雪崩時, 針對不同的資料採取不同的降級方案, 例如, 非核心資料直接返回預設值、空值或是錯誤資訊。</li>
</ul>
</li>
<li>快取當機<ul>
<li>系統中實現服務熔斷或請求限流機制, 防止大量訪問使得資料庫當機。</li>
</ul>
</li>
</ul>
<h4 id="快取穿透"><a href="#快取穿透" class="headerlink" title="快取穿透"></a>快取穿透</h4><p>資料在資料庫和快取中都不存在, 導致查詢資料時, 在快取中找不到對應key的值, 都會去資料庫再查詢一遍,然後資料庫也返回空值(相當於進行了兩次無用的查詢)。</p>
<p>解決方案</p>
<ul>
<li>快取空值或預設值 : 當一個查詢返回的資料為空時, 空結果也將進行快取, 並將它的過期時間設定比較短, 下次訪問直接從快取中取值, 避免了把大量請求給資料庫處理,造成資料庫出問題。</li>
<li>布隆過濾器(BloomFilter) : 將所有可能查詢資料key雜湊到一個足夠大的bitmap中, 在查詢的時候先去BloomFilter去查詢key是否存在, 如果不存在就直接返回, 存在再去查詢快取, 快取中沒有再去查詢資料庫 , 從而避免了資料庫的壓力爆增導致當機。</li>
</ul>
<h4 id="快取擊穿"><a href="#快取擊穿" class="headerlink" title="快取擊穿"></a>快取擊穿</h4><p>針對某個訪問非常頻繁的資料過期失效, 導致訪問無法在快取中進行處理, 進而導致大量的請求在資料庫處理, 從而使得資料庫的壓力爆增, 嚴重的會造成當機。</p>
<p>解決方案</p>
<ul>
<li>對於訪問頻繁的資料, 不設定過期時間。</li>
</ul>
<h4 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h4><p>在大部分的業務場景中, Redis 快取只作為只讀取使用, 優先處理資料庫後再處理快取, 藉此確保資料的一致性。</p>
<p>至於其他的問題請參考下表</p>
<table>
<thead>
<tr>
<th>問題</th>
<th>原因</th>
<th>解決方案</th>
</tr>
</thead>
<tbody><tr>
<td>快取雪崩</td>
<td>大量資料同時過期失效, 快取當機</td>
<td>資料預熱、設定不同的過期時間、雙層快取策略、服務降級、服務熔斷、限流機制</td>
</tr>
<tr>
<td>快取穿透</td>
<td>資料同時不存在資料庫和快取中</td>
<td>快取空值或預設值、布隆過濾器(BloomFilter)</td>
</tr>
<tr>
<td>快取擊穿</td>
<td>訪問非常頻繁的資料過期失效</td>
<td>不設定過期時間</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
</search>
